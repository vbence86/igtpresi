<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Scratchomatic/scripts/uncompressed/main.js - Scratchomatic</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Scratchomatic" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/CanvasText.html">CanvasText</a></li>
                                <li><a href="../classes/CanvasToolkit.html">CanvasToolkit</a></li>
                                <li><a href="../classes/EasingFunctions.html">EasingFunctions</a></li>
                                <li><a href="../classes/Point.html">Point</a></li>
                                <li><a href="../classes/ScratchAnimationTriggers.html">ScratchAnimationTriggers</a></li>
                                <li><a href="../classes/ScratchBrushTypes.html">ScratchBrushTypes</a></li>
                                <li><a href="../classes/ScratchController.html">ScratchController</a></li>
                                <li><a href="../classes/ScratchGameTypes.html">ScratchGameTypes</a></li>
                                <li><a href="../classes/ScratchMask.html">ScratchMask</a></li>
                                <li><a href="../classes/Symbol.html">Symbol</a></li>
                                <li><a href="../classes/SymbolGroup.html">SymbolGroup</a></li>
                                <li><a href="../classes/SymbolZIndices.html">SymbolZIndices</a></li>
                                <li><a href="../classes/TimeLine.html">TimeLine</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/CanvasText.html">CanvasText</a></li>
                                <li><a href="../modules/CanvasToolkit.html">CanvasToolkit</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: Scratchomatic/scripts/uncompressed/main.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
.
.
. :::::,                   :?N.                ?8,       8M  +Z7 IM~                                  =$O
. MMMMMMMD                .8MN.                MM.       NM  MM7 $M=  ,NN                             MMO
. MMD   MMO                8MN                 MM            MM7      :MN                             MMO
. MMD   MMZ+MMMMM MMMMMMM  8MMMMMMM   MMMMMM8  MMMMMMMO  MM  MM7 MMZ MMMMMMM NMM   MMD      7MMMMMMM: MMO  MMMMMMM
. MMD   MMZ+MM:  7MM   MMN 8MN   8MM      :MM, MM    MM: MM  MM7 MMZ. ~MN    NMM   MMD      7MM   DMM MMO OMZ  .MM
. MMMMMMMM +MM.  IMM   MMN 8MN   8MM     8MMM, MM.   MM: MM  MM7 MMZ  ~MN    NMM   MMD      7MM   8MM.MMO OMZ
. MMN      +MM.  IMM   MMN 8MN   8MM  =MMMIMM, MM    MM: MM  MM7 MMZ. ~MN    NMM   MMD      7MM   8MM.MMO OMZ
. MMD      +MM.  IMM   MMN 8MN   8MM NMM   MM, MM    MM: MM  MM7 MMZ  ~MN    NMM   MMD      7MM   8MM.MMO OMZ
. MMD      +MM.  IMM   MMN 8MN   8MM MM:   MM, MM    MM: MM  MM7 MMZ. ~MN    NMM   MMD      7MM   8MM.MMO OMZ   $M
. MMD      +MM.  .MMNO8MM= 8MMNODMM+ NMM8OMMM, MMM8ONMM. MM  MM7 MMZ ..MMD8D =MMNODMMD      7MMNZDMMO MMO.,MMNONMM
.                                                                                  MMD      7MM,I7:
.                                                                                  MMD      7MM
.                                                                                  +?+      ~??.

 Probability PLC
 Scratch-O-Matic
 Reshma Pinto, Darren Beukes, Luca Borrione, Bence Varga, Robert Moir, Renjith Abby

 */
/** --------------------------------------------------------------------------------------------------- **/
/** requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel                **/
/** MIT License                                                                                         **/
/** --------------------------------------------------------------------------------------------------- **/
(function() {
    var lastTime = 0;
    var vendors = [&#x27;webkit&#x27;, &#x27;moz&#x27;];
    for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+&#x27;RequestAnimationFrame&#x27;];
        window.cancelAnimationFrame =
            window[vendors[x]+&#x27;CancelAnimationFrame&#x27;] || window[vendors[x]+&#x27;CancelRequestAnimationFrame&#x27;];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };

}());
/** --------------------------------------------------------------------------------------------------- **/


/**
 * Main game logic to collect all the required hooks and callbacks to initialise the game
 *
 * @param  {[object Object]} window    global window object
 * @param  {[object Object]} document  reference to the top-most DOMElement object
 * @param  {[undefined]} undefined [description]
 * @return {none}
 */
(function(toolkit, window, document, undefined){

    // Helper functions and variables
    // DOM grabber
    var $ = toolkit.$,

    // list of cross browser &quot;animationend&quot; eventlisteners
        EVENT_ANIMATIONEND = [
            &#x27;animationend&#x27;,
            &#x27;webkitAnimationEnd&#x27;,
            &#x27;oanimationend&#x27;,
            &#x27;mozanimationend&#x27;,
            &#x27;MSanimationend&#x27;
        ],

        EVENT_TRANSITIONEND = [
            &#x27;webkitTransitionEnd&#x27;,
            &#x27;transitionend&#x27;,
            &#x27;oTransitionEnd&#x27;,
            &#x27;otransitionend&#x27;,
            &#x27;transitionend&#x27;
        ],

        isDesktop = function(){
            return &quot;default&quot; === userAgent.OS;
        };

    // this function is being called by the framework after the preloading process has finished
    this.game_main = function(resp){
        if(userAgent.isAndroidStockBrowser()) {
            // There is a bug on some versions of the android browser which breaks the rendering on the first canvas added to the page.
            // This can be worked around by adding an invisible, sacrificial canvas to the top of the page
            // (see https://jira.probability.co.uk/browse/SCRAT-569 and others)
            var decoy = document.createElement(&quot;canvas&quot;),
                container = document.getElementById(&quot;game-scene&quot;);
            decoy.width = 10;
            decoy.height  = 10;
            decoy.style.position = &quot;fixed&quot;;
            container.insertBefore(decoy, container.childNodes[0]);
        }

        // Setting up states and event transitions
        // The established StateMachine object is being introduced in the pgc.Game.StateMachine variable
        // @link https://wiki.probability.co.uk/display/DEV/Getting+started+with+pgc.GameStateMachine+library
        pgc.Game.setupGameStateMachine();

        // starting the scratch controller
        pgc.Game.ScratchController = new ScratchController();

        // Initialise the game audio
        pgc.Game.initAudio();

        // calling the game specific business logic if it has been implemented
        pgc.Game.trigger(&quot;ready&quot;);

        // entering to the Init state
        pgc.Game.StateMachine.init(resp);        
    };


    /** --------------------------------------------------------------------------------------------------- **/
    /** Localisation setup                                                                                  **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.initLocalisation = function(){

        //toolbar
        writeText(&quot;bankTitle&quot;, &quot;toolbar.bankTitle&quot;);
        writeText(&quot;betTitle&quot;, &quot;toolbar.betTitle&quot;);
        writeText(&quot;winTitle&quot;, &quot;toolbar.winTitle&quot;);

        // purchase scene
        writeText(&quot;purchase-button-text&quot;, &quot;purchase.button.purchase&quot;);

        // selection scene
        writeText(&quot;selection-title-text&quot;, &quot;selection.title&quot;);
        
        //main screen
        writeText(&quot;scratch-all-button-text&quot;, &quot;ingame.button.scratch-all&quot;);

    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Function to switch between Purchase and Game scenes                                                 **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.switchSceneTo = (function() {
        var current;

        return function (sceneId) {
            if (!sceneId) {
                return;
            }

            if (current) {
                $(&quot;#&quot; + current).removeClass(&quot;shown&quot;);
            }
            $(&quot;#&quot; + sceneId).addClass(&quot;shown&quot;);
            current = sceneId;
        };

    })();


    /** --------------------------------------------------------------------------------------------------- **/
    /** --                                          SELECTION FLOW                                          **/
    /** --------------------------------------------------------------------------------------------------- **/
    (function(module){

        var MAX_SKINS = 3,
            selectedClass = &quot;selected&quot;,
            unSelectedClass = &quot;unselected&quot;,
            blockerClass = &quot;selectionFinished&quot;,

            /** --------------------------------------------------------------------------------------------------- **/
            /** Setting up the Purchase scene                                                                       **/
            /** --------------------------------------------------------------------------------------------------- **/
            initPurchaseScene = function(){

                var purchaseCards = document.getElementsByClassName(&quot;purchase-card&quot;),
                    selectedSkinId,

                    addClickListenerToPurchaseButton = function(){

                        $(&quot;#purchase-button&quot;).bind(DOMUtil.touchEvent, function(){
                            $(&quot;#purchase-button&quot;).addClass(&quot;pressed&quot;);
                            // @TODO &quot;unresponsible Kjop&quot; button bugfix - find out why that bug occurs and remove this hack
                            if (pgc.Game.StateMachine.current === &quot;Intro&quot; &amp;&amp; window.initialise &amp;&amp; !window.initialise.hasItBeenCalled){
                                pgc.Game.StateMachine.current = &quot;Purchase&quot;;
                            }
                            //selectedSkinId = 2;
                            setChosenSkin(selectedSkinId || getRandomizedChosenTheme());
                            pgc.Game.StateMachine.selection();
                        });

                    },

                    getRandomizedChosenTheme = function(){
                        return Math.floor(Math.random() * MAX_SKINS) + 1;
                    },

                    addClicklistenerToPurchaseCards = function(){
                        for (var i = purchaseCards.length - 1; i &gt;= 0; i--) {
                            // add click listeners for each of the cards
                            purchaseCards[i].addEventListener(DOMUtil.touchEvent, function(){
                                selectPurchaseCard(this);
                                setChosenThemeBySelectedPurchaseCard(this);
                            });
                        }
                    },

                    selectPurchaseCard = function(card){
                        for (var i = purchaseCards.length - 1; i &gt;= 0; i--) {
                            $(purchaseCards[i]).removeClass(selectedClass);
                            $(purchaseCards[i]).addClass(unSelectedClass);
                        }
                        $(card).removeClass(unSelectedClass);
                        $(card).addClass(selectedClass);
                    },

                    setChosenThemeBySelectedPurchaseCard = function(card){
                        if (!card){
                            return;
                        }
                        // storing the chosen theme in the pgc.Game object for further usage
                        var match = /skin\-(\d)/.exec(card.className);
                        if (match &amp;&amp; match[1]){
                            selectedSkinId = parseInt(match[1]);
                        }
                    };

                addClickListenerToPurchaseButton();
                // adding listeners to the cards on desktop browsers so that the user can choose between cards
                if (&quot;default&quot; === userAgent.OS &amp;&amp; pgc.Game.isOldSelectionFlow()){
                    addClicklistenerToPurchaseCards();
                }

            },


            /** --------------------------------------------------------------------------------------------------- **/
            /** Setting up the Purchase scene                                                                       **/
            /** --------------------------------------------------------------------------------------------------- **/
            initSelectionScene = function(){

                var selectionCards = document.getElementsByClassName(&quot;selectionCardContainer&quot;),
                    selectionScene = $(&quot;#selection-scene&quot;),
                    selectedSkinId,

                    addClicklistenerToSelectionCards = function(){
                        for (var i = selectionCards.length - 1; i &gt;= 0; i--){
                            selectionCards[i].addEventListener(DOMUtil.touchEvent, function(){
                                handleSelection(this);
                            });
                        }
                    },

                    handleSelection = function(card){
                        if ($(selectionScene).hasClass(blockerClass)){
                            return;
                        }
                        selectSelectionCard(card);
                        setChosenThemeBySelectedSelectionCard(card);
                        playClickSound();
                        enterToIntro();
                    },

                    selectSelectionCard = function(card){
                        $(card).addClass(selectedClass);
                        $(selectionScene).addClass(blockerClass);
                    },

                    setChosenThemeBySelectedSelectionCard = function(card){
                        if (!card){
                            return;
                        }
                        // storing the chosen theme in the pgc.Game object for further usage
                        var selectionCardChild = card.firstChild,
                            match = /skin\-(\d)/.exec(selectionCardChild.className);
                        if (match &amp;&amp; match[1]){
                            selectedSkinId = parseInt(match[1]);
                            setChosenSkin(selectedSkinId);
                        }
                    },

                    playClickSound = function(){
                        if ( pgc.Game.isAudioEngineDelayedLoad() ) {
                            pgc.Game.preloadAudioMobileFallback();
                        } else {
                            // @TODO the AudioEngine should handle the exceptions triggered by native code
                            try {
                                pgc.Game.getAudioEngine().playSound(pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.main), pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.cardSelection));
                            } catch (ex) {}
                        }
                        pgc.Game.updateAmbientLastEventTime();
                    },

                    enterToIntro = function(){
                        $(document).wait(1000).then(function(){
                            pgc.Game.StateMachine.intro();
                        });                        
                    };

                addClicklistenerToSelectionCards();

            },

            resetSelectionScene = function(){

                var selectionCards = document.getElementsByClassName(&quot;selectionCardContainer&quot;),
                    selectionScene = $(&quot;#selection-scene&quot;),

                    unselectAllCards = function(){
                        for (var i = selectionCards.length - 1; i &gt;= 0; i--){
                            $(selectionCards[i]).removeClass(selectedClass);
                        }
                    },

                    removeSelectionBlocker = function(){
                        $(selectionScene).removeClass(blockerClass);
                    };

                unselectAllCards();
                removeSelectionBlocker();

            };

        module.initSelectionFlow = function(){
            initPurchaseScene();
            initSelectionScene();
        };

        module.resetSelectionFlow = function(){
            resetSelectionScene();
        };

        module.MAX_SKINS = MAX_SKINS;

    })(window);    

    /** --------------------------------------------------------------------------------------------------- **/
    /** Exposing a function to global scope to set the Chosen skin                                          **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.setChosenSkin = function(chosenSkinId){
        if (!chosenSkinId){
            return;
        }
        pgc.Game.chosenTheme = chosenSkinId &gt; 0 ? chosenSkinId : 1;
        if (pgc.Game.UserData){
            pgc.Game.UserData.setUserData(&quot;chosenTheme&quot;, chosenSkinId);
        }
        // adding body tag depending on the chosen skin
        for (var i = 0; i &lt; MAX_SKINS; i++){
            $(document.body).removeClass([&quot;Skin-&quot;, i + 1].join(&quot;&quot;));
        }
        $(document.body).addClass(&quot;Skin-&quot; + (chosenSkinId || pgc.Game.chosenTheme));
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Initialising UserData (helper for localStorage)                                                     **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.initUserData = function(){
        var userData = new UserData(StorageTypes.LOCAL_STORAGE),
            getUniqueKey = function(key){
                return [pgc.Game.userAppId, &quot;-&quot;, pgc.Game.scardId, &quot;_&quot;, key].join(&quot;&quot;);
            };


        userData.setGameSpecificData = function(key, value){
            if (!value || !key){
                return;
            }
            userData.setUserData(getUniqueKey(key), value);
        };

        userData.getGameSpecificData = function(key){
            return userData.getUserData(getUniqueKey(key));
        };

        pgc.Game.UserData = userData;
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Loading function for resuming unfinished games                                                      **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.loadUnfinishedGameData = function(){
        for(var i = 0; i &lt; pgc.Game.scratchSceneReferences.length; i++) {
            var data;
            if (!pgc.Game.scratchSceneReferences[i]){
                continue;
            }
            data = pgc.Game.UserData.getGameSpecificData(pgc.Game.scratchSceneReferences[i].id);
            if(data !== null &amp;&amp; &quot;function&quot; === typeof pgc.Game.scratchSceneReferences[i].load) {
                pgc.Game.scratchSceneReferences[i].load(data);
            }
        }
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Resetting the unfinished game data                                                                  **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.resetSavedGameData = function(){
        for (var i = 0; i &lt; pgc.Game.scratchSceneReferences.length; i++) {
            pgc.Game.UserData.setGameSpecificData(pgc.Game.scratchSceneReferences[i].id, JSON.stringify([]));
        }
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Initialising the function for changing the current scratch tool                                     **/
    /** --------------------------------------------------------------------------------------------------- **/
    /**
     * Generating and exposing a function that can set the current scratching tool on the ScratchController
     * @method setScratchToolHandler
     * @param scratchBrushSprites {Array} Array of PGCSprites
     */
    this.setScratchToolHandler = function(scratchBrushSprites){

        var dataKey = &quot;selectedScratchTool&quot;,
            // load the save tool ID to set it up accordingly or use the default one
            currentScratchToolId = pgc.Game.UserData.getGameSpecificData(dataKey) || 1,
            toolButton = $(&quot;#tool-button&quot;),

            // Building up the required listeners for the ToolButton and determining which should be the default value
            toolItems = $(toolButton).find(&quot;.selectableItemsContainer&quot;).getElementsByTagName(&quot;div&quot;),
            toolSelected = $(toolButton).find(&quot;.selectedItem&quot;),
            attrKey = &quot;data-value&quot;,
            isMobile = (function(userAgent){
                return userAgent.isIOS() || userAgent.isAndroid() || userAgent.isIEMobile();
            })(window.userAgent);

            var selectScratchToolByElement = function(elm){
                if (!elm){
                    return;
                }

                // removing the current body tag that indicates the selected tool ID
                $(document.body).removeClass(&quot;selectedScratchTool-&quot; + pgc.Game.selectedScratchTool);

                // expsoing the selected value for later usage
                pgc.Game.selectedScratchTool = parseInt(elm.getAttribute(attrKey)) || 1;

                // setting the DOM element to reflect the selected tool
                toolSelected.setAttribute(attrKey, pgc.Game.selectedScratchTool);

                // persisting the selected ID
                pgc.Game.UserData.setGameSpecificData(dataKey, pgc.Game.selectedScratchTool);

                // setting up a a body tag that indicates the selected tool&#x27;s ID
                $(document.body).addClass(&quot;selectedScratchTool-&quot; + pgc.Game.selectedScratchTool);

                // resetting the idle timer since it&#x27;s a kind of a user-interaction 
                if (pgc.Game.idleManager){
                    pgc.Game.idleManager.reset();
                }
            };

            var selectScratchToolById = function(id){
                id = parseInt(id);
                for (var i = toolItems.length - 1; i &gt;= 0; i--) {
                    if (id === parseInt(toolItems[i].getAttribute(attrKey))){
                        selectScratchToolByElement(toolItems[i]);
                        return;
                    }
                }
            };

            var setScratchToolById = function(toolId){

                var sprite, type,
                    // @TODO: setting the default scaling percentage on mobiles should be somewhere 
                    // outside this function, I bealive
                    scaling = isMobile ? 1.75 : 1;

                if (!pgc.Game.ScratchController || !scratchBrushSprites){
                    return;
                }

                toolId = parseInt(toolId) || 1;
                sprite = scratchBrushSprites[toolId - 1];
                type = toolId === 3 ? pgc.ScratchBrushTypes.WAND : pgc.ScratchBrushTypes.SCRATCH;

                pgc.Game.ScratchController.setScratchBrush({
                    brushType: type,
                    brushSprite: sprite,
                    scaling: scaling
                });
                selectScratchToolById(toolId);

            };

        // linking click listeners to the selectable items
        for (var i = toolItems.length - 1; i &gt;= 0; i--){

            if (!toolItems[i]){
                continue;
            }

            // determining if the current element is the default and set the default value accordingly
            if ($(toolItems[i]).hasClass(&quot;default&quot;)){
                selectScratchToolByElement(toolItems[i]);
            }

            // adding event listeners on click for each of the selectable items
            toolItems[i].addEventListener(DOMUtil.touchEvent, (function(item){
                return function(){
                    selectScratchToolByElement(item);
                    pgc.Game.trigger(&quot;scratchtoolchanged&quot;, pgc.Game.selectedScratchTool);
                    setScratchToolById(pgc.Game.selectedScratchTool);
                };
            })(toolItems[i]));
        }

        // exposing a function to the global scope to have the ability to change the selected tool from outside
        pgc.Game.setScratchToolById = setScratchToolById;

        // set the current tool which is either the saved or the default one
        setScratchToolById(currentScratchToolId);

    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Adding event listeners for controls                                                                 **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.addEventListeners = function() {

        var toolButton = document.getElementById(&quot;tool-button&quot;),
            toolButtonBox = document.getElementById(&quot;tool-button-box&quot;),
            toolButtonMenu = document.getElementById(&quot;tool-button-items&quot;),
            scratchAllButton = document.getElementById(&quot;scratch-all-button-text&quot;);

        // set up event listeners. save here so they can be moved / reused
        this.scratchEventListeners = {

            // Tool Button
            toolButton: function() {
                var button = $(toolButtonBox),
                    buttonBox = $(toolButtonBox),
                    buttonItems = $(toolButtonMenu);
                if (!toolButton){
                    return;
                }
                if (toolButton.hasClass(&quot;disabled&quot;)){
                    return;
                }
                if (toolButton.hasClass(&quot;opened&quot;)){
                    toolButton.removeClass(&quot;opened&quot;);
                    toolButtonBox.removeClass(&quot;opened&quot;);
                    toolButtonMenu.removeClass(&quot;opened&quot;);
                } else {
                    toolButton.addClass(&quot;opened&quot;);
                    toolButtonBox.addClass(&quot;opened&quot;);
                    toolButtonMenu.addClass(&quot;opened&quot;);
                }

                pgc.Game.idleManager.reset();
            },

            // Scratch-All button - might be excluded on a game-by-game basis
            scratchAll: function() {
                // the button is not allowed to use in any state, but &quot;InGame&quot;
                if (pgc.Game.StateMachine.current !== &quot;InGame&quot;){
                    return;
                }

                if ($(this).hasClass(&quot;disabled&quot;)){
                    return;
                }

                //Cycle through all symbols and reveal them
                for (var i = pgc.Game.symbolGroupReferences.length - 1; i &gt;= 0; i--) {
                    pgc.Game.symbolGroupReferences[i].revealAll();
                }

                pgc.Game.updateAmbientLastEventTime();
                pgc.Game.getAudioEngine().playSound(pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.main), pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.scratchAll));

                // scratchScenes_Dirty = true;
                pgc.Game.idleManager.reset();
            }

        };

        // add event listeners
        if (toolButton) {
            toolButton.addEventListener( DOMUtil.touchEvent, this.scratchEventListeners.toolButton );
        }
        if (scratchAllButton) {
            scratchAllButton.addEventListener( DOMUtil.touchEvent, this.scratchEventListeners.scratchAll );
        }

        // setting up a listener to check if the last animation for the intro has been finished
        listenToLastAnimation();

        //setting up Popups handlers
        [&quot;nowin-popup&quot;, &quot;win-popup&quot;, &quot;bonuswin-popup&quot;].forEach(function(popupId){

            if (!document.getElementById(popupId)){
                return;
            }

            PopupHelper
                .addPopupButtonListener(popupId)
                .press(function(){
                    // we need to indicate that the user has pressed the OK button in order to
                    // hold up getting back to the buy screen until the &quot;finish&quot; message has been processed
                    pgc.Game.EndGamePopupConfirmed = true;
                    pgc.Game.StateMachine.finish();
                })
                .onHideAnimationEnd(function(){
                    pgc.Game.StateMachine.finish();
                });

        });

        PopupHelper
            .addPopupButtonListener(&quot;popup-scene-container&quot;)
            .click(function(){
                pgc.Game.StateMachine.inGame();
            });

    };


    /** --------------------------------------------------------------------------------------------------- **/
    /** Checking if the last animation for the intro has been finished                                      **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.listenToLastAnimation = function(){
        /**
         * If there are no intro popups you can make any one animated element a member of the last-
         * intro-animation class
         */
        var temp = $(&quot;.last-intro-animation&quot;);
        if(temp !== null) {
            for (var i = EVENT_ANIMATIONEND.length - 1; i &gt;= 0; i--) {
                temp.unbind(EVENT_ANIMATIONEND[i]);
            }
            temp.bind(EVENT_ANIMATIONEND, function(evt) {
                var event = evt || window.event;
                if(this.id == event.target.id){
                    if (pgc.Game.StateMachine.current !== &quot;InGame&quot;){
                        pgc.Game.StateMachine.inGame();
                    }
                }
                // invoking all the registered callbacks for this event
                pgc.Game.trigger(&quot;lastintroanimation&quot;, evt);
            });
        }
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Popup helper object                                                                                 **/
    /** provides unified function to register callbacks on the ingame popups                                **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.PopupHelper = (function(toolkit){

        var $ = toolkit.$,

            // key value set to store all the generated popup helper objects
            popups = {},

            // -- Added this parameter to keep the scene faded even after the popup is closed
            sceneFaderOn = false;

        return {

            addPopupButtonListener: function(popupId){
                var popupContainer = $(&quot;#&quot; + popupId),
                    fader = $(&quot;#sceneFader&quot;),
                    okButton = popupContainer &amp;&amp; $(popupContainer).find(&#x27;.okButton&#x27;),
                    mainbar = $(&quot;.main-game-bar&quot;),
                    visible = false,

                    events = new toolkit.EventDispatcher(),

                    // showing the popup
                    show = function(keepSceneFaded){
                        var fader = $(&quot;#sceneFader&quot;),
                            mainbar = $(&quot;.main-game-bar&quot;);

                        sceneFaderOn = keepSceneFaded || false;

                        visible = true;

                        $(popupContainer).addClass(&quot;shown&quot;);


                         if (fader){
                            fader.addClass(&quot;shown&quot;);
                            if(mainbar) {
                                mainbar.addClass(&quot;hideBehindFader&quot;);
                            }
                         }

                    },

                    // making the popup disappear gracefully
                    hide = function(callback, forceHide){

                        if (!visible){
                            return;
                        }

                        /* [NOTE] : shown class defines a transition on opacity.
                        * It conflicts with the simplaefade out animation hence modified it to
                        * be set to visibility : hidden at end of animation */
                        $(popupContainer)
                            .addClass(&quot;simpleFadeOut&quot;)
                            .bind(EVENT_ANIMATIONEND, function(){

                                // the object can have multiple animations thus we remove this callback straightaway
                                for (var key in EVENT_ANIMATIONEND){
                                    $(popupContainer).unbind(EVENT_ANIMATIONEND[key]);
                                }

                                $(popupContainer).removeClass(&quot;shown&quot;);

                                visible = false;

                                /* ==  IN Summary state we want the game stays faded out, hence introduced a new flag to manage this === */
                                if (fader &amp;&amp; (!sceneFaderOn || forceHide)){
                                    fader.removeClass(&quot;shown&quot;);
                                }
                                if(mainbar) {
                                    mainbar.removeClass(&quot;hideBehindFader&quot;);
                                }

                                if (okButton){
                                    okButton.removeClass(&quot;pressed&quot;);
                                }

                                if (&quot;function&quot; === typeof callback){
                                    callback();
                                }

                                // ADDING THE REMOVE CLASS IN HERE INSTEAD OF IN THE SHOW FUNCTION, as prev caused Issue on SAFARI in WINDOWS OS. TICKET: SCRAT-938
                                $(popupContainer).removeClass(&quot;simpleFadeOut&quot;);

                                events.dispatch(&quot;hideAnimationEnd&quot;);

                            });
                    },

                    popup = {
                        // exposing a function for adding business logic to the OK button
                        click: function(callback){
                            if (!okButton){
                                return this;
                            }
                            okButton.bind(DOMUtil.touchEvent, function(){

                                // hiding the popup and invoking the passed callback
                                hide(callback);

                                // playing sound for clicking the ok button
                                pgc.Game.getAudioEngine().playSound(pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.main), pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.control), function(){
                                    // playing sound for closing the popup once playing the click sound has finished
                                    pgc.Game.getAudioEngine().playSound(pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.main), pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.close));
                                });

                            });

                            return this;
                        },

                        // the &quot;press&quot; event merely applies the &quot;pressed&quot; class on the corresponding button element
                        press: function(callback){
                            if (!okButton){
                                return this;
                            }
                            okButton.bind(DOMUtil.touchEvent, function(){

                                okButton.addClass(&quot;pressed&quot;);

                                if (&quot;function&quot; === typeof callback){
                                    // passing &#x27;this&#x27; as a reference to the popup helper object
                                    callback(this);

                                }

                                // playing sound for clicking the ok button
                                pgc.Game.getAudioEngine().playSound(pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.main), pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.control), function(){
                                    // playing sound for closing the popup once playing the click sound has finished
                                    pgc.Game.getAudioEngine().playSound(pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.main), pgc.Game.ScratchController.skinSelect(pgc.Game.audio.names.close));
                                });

                            });
                            return this;
                        },

                        // onHideAnimationEnd event is triggered when hiding the popup has been finished off
                        onHideAnimationEnd: function(callback){
                            events.addEventListener(&quot;hideAnimationEnd&quot;, callback);
                            return this;
                        },

                        // exposing the hide function as it&#x27;s required to be used from outside
                        hide: function(callback, forceHide){
                            hide(callback, forceHide);
                            return this;
                        },

                        // exposing the show function as it&#x27;s required to be used from outside
                        show: function(keepSceneFaded){
                            show(keepSceneFaded);
                            return this;
                        },

                        isShown: function(){
                            return !!visible;
                        }

                    };

                // saving the reference to the newly created helper popup
                popups[popupId] = popup;

                return popup;

            },
            /* == Added this if we need to disable the fader later on === */
            hideSceneFader : function(){
                var fader = $(&quot;#sceneFader&quot;);
                if (fader){
                    fader.removeClass(&quot;shown&quot;);
                }
            },

            showPopup: function(popupId, keepSceneFaded){
                var popup = popups[popupId];

                if (!popup){
                    return;
                }
                $(&quot;body&quot;).addClass(&quot;onPopUp&quot;);
                popup.show(keepSceneFaded);
            },

            hidePopup: function(popupId, forceHide){
                var popup = popups[popupId];

                if (!popup){
                    return;
                }
                $(&quot;body&quot;).removeClass(&quot;onPopUp&quot;);
                popup.hide(null, forceHide);
            },

            hideAll: function(forceHide){
                if (!popups){
                    return;
                }
                for (var i in popups){
                    if (!popups[i] || &quot;function&quot; !== typeof popups[i].hide){
                        continue;
                    }
                    popups[i].hide(null, forceHide);
                }
                $(&quot;body&quot;).removeClass(&quot;onPopUp&quot;);
            },

            isAllHidden: function(){
                if (!popups){
                    return true;
                }
                for (var i in popups){
                    if (popups[i] &amp;&amp; &quot;function&quot; === typeof popups[i].isShown &amp;&amp; popups[i].isShown()){
                        return false;
                    }
                }
                return true;
            }

        };

    })(toolkit);

    /** --------------------------------------------------------------------------------------------------- **/
    /** Determine if there is any kind of winning-combination on the scratch-card                           **/
    /** --------------------------------------------------------------------------------------------------- **/
   this.hasInstantWin = function(scratchZone){
        return getInstantWinAmount(scratchZone) &gt; 0;
   };

   this.getInstantWinAmount = function(scratchZone){
        var winningCombinations = scratchZone.winningCombinations;
        return winningCombinations[&quot;-1&quot;] &amp;&amp; parseInt(winningCombinations[&quot;-1&quot;].winAmount) || 0;
    };

    this.hasWin = function(scratchZone){
        var winningCombinations = scratchZone.winningCombinations;
        return winningCombinations &amp;&amp; Object.keys(winningCombinations).length;
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Adding a helper function that forces the canvas attached to a SratchScene to get refreshed          **/
    /** --------------------------------------------------------------------------------------------------- **/
    this.refreshScratchSceneHack = function(scratchScene){
        if (!scratchScene){
            return;
        }
        var scenes = Array.prototype.concat.call(scratchScene);
        scenes.forEach(function(scene){
            scene.context.clearRect(0, 0, 1, 1);
        });
    };

    /** --------------------------------------------------------------------------------------------------- **/
    /** Subscribing commonly used callbacks to idle                                                         **/
    /** --------------------------------------------------------------------------------------------------- **/
    (function(){
        pgc.Game.idle(function(){
            var wrapper = $(&quot;.scratchAllButtonWrapper&quot;);
            if (wrapper) {
                wrapper.animateOnce(&quot;Idle&quot;);
            }
        }, 5000);
    })();

    /** --------------------------------------------------------------------------------------------------- **/
    /** Subscribing commonly used callbacks to heartbeating                                                 **/
    /** --------------------------------------------------------------------------------------------------- **/
    (function(showHeartbeat){
        // allow the visualisation of the heartbeat
        if (!showHeartbeat){
            return;
        }
        // Adding visual representation for the heartbeat for testing purposes
        pgc.Game.heartbeat(function(){
            var body = $(document.body),
                heartbeatClass = &quot;Heartbeat&quot;;

            body.addClass(heartbeatClass)
                .wait(1000)
                .then(function(){
                    body.removeClass(heartbeatClass);
                });
        }, 5000);
    })(__visualiseHeartbeat === &quot;true&quot;);    

    /** --------------------------------------------------------------------------------------------------- **/
    /** adding BODY TAGS                                                                                    **/
    /** --------------------------------------------------------------------------------------------------- **/
    (function(toolkit){
        function inIframe () {
            try {
                return window.self !== window.top;
            } catch (e) {
                return true;
            }
        }

        function isSonyXperiaZ(){
            return new RegExp(/C6603/).test(userAgent.userAgentString);
        }

        function isIE11(){
            var trident = !!navigator.userAgent.match(/Trident\/7\.0/),
                net = !!navigator.userAgent.match(/.NET4\.0E/),
                version = !!navigator.userAgent.match(/.rv\:11/);
            return trident &amp;&amp; (net || version);
        }

        function isWindows81(){
            return userAgent.userAgentString.match(/Windows NT 6\.3/);
        }

        if (inIframe()){
            toolkit.$(document.body).addClass(&quot;IFrame&quot;);
        }

        if(isDesktop()){
            toolkit.$(document.body).addClass(&quot;Desktop&quot;);
        }

        if (isSonyXperiaZ()) {
            toolkit.$(document.body).addClass(&quot;SonyXperiaZ&quot;);
        }

        if (userAgent.isIPhone()) {
            toolkit.$(document.body).addClass(&quot;iPhone&quot;);
        }

        if (isIE11()){
            toolkit.$(document.body).addClass(&quot;IE11&quot;);
        }

        if (isWindows81()){
            toolkit.$(document.body).addClass(&quot;Windows81&quot;);   
        }

        if(userAgent.isChrome() &amp;&amp; !userAgent.isDesktop() &amp;&amp; userAgent.isAndroid()){
            toolkit.$(document.body).addClass(&quot;ChromeAndroid&quot;);
        }

    })(toolkit);

    //-- Adding the client config for setting the timeout
    if(window.touchCasinoBrandConf &amp;&amp; window.touchCasinoBrandConf.clientTimeout){
        pgc.Game.clientOptions = {
            clientTimeout : touchCasinoBrandConf.clientTimeout
         };
    }

})(PGCUniverse.PGCToolkit, window, window.document);

/** wrapper function to put text in an element using the i18n utilities
 * @param {String} elemName DOM element to add text to
 * @param {String} stringName localised string key
 * @param {String} defaultString default string to use if no localised string is available
 * @param {String} surroundWithSpaces flag to wrap the string with &amp;nbsp; characters
 */
function writeText(elemName, stringName, defaultString, surroundWithSpaces) {
    var str;
//    console.debug(stringName);
    if(document.getElementById(elemName) !== null) {
        if(defaultString !== undefined &amp;&amp; defaultString.length &gt; 0)
        {
            str = getLocalisedStringWithDefaultText(stringName, defaultString);
        }
        else if(stringName.length &gt; 0) {
            str = getLocalisedString(stringName);
        }
        if (surroundWithSpaces){
            str = [&quot;&amp;nbsp;&quot;, str, &quot;&amp;nbsp;&quot;].join(&#x27;&#x27;);
        }
        document.getElementById(elemName).innerHTML = str;
    }
}

/** --------------------------------------------------------------------------------------------------- **/
/** updates the win popup winning-combinations-table                                                    **/
/** --------------------------------------------------------------------------------------------------- **/
var WinPopupTable = PGCClass.extend({
	init : function(){
		this.$ = PGCUniverse.PGCToolkit.$;
	},

	createRow: function(columns){
		var column, row, i, l, p;

		if (!columns){
			return;
		}

		row = document.createElement(&quot;div&quot;);
		row.setAttribute(&quot;class&quot;, &quot;wintable-row&quot;);

		for (i = 0, l = columns.length; i &lt; l; i++) {

			column = document.createElement(&quot;div&quot;);
			column.setAttribute(&quot;class&quot;, &quot;wintable-column&quot;);

			p = document.createElement(&quot;p&quot;);

			//-- Commented the use of createTextNode, as this would not parse the &amp;pound; sign
	//                  p.appendChild(document.createTextNode(columns[i]));
			p.innerHTML = columns[i];

			column.appendChild(p);
			row.appendChild(column);

		}
		return row;
	},

	createContent: function(scratchZone, _currencyManager){

		// currency manager
		var currencyManager = _currencyManager || pgc.Game.multiCurrenctManager,

		// datas from the server
			userFoils = scratchZone.userFoils,
			winningCombinations = scratchZone.winningCombinations,
			playFields = scratchZone.playFields,
			totalWin = scratchZone.totalWin,

		// Total win amount


		// helper variables
			key;

		if (!scratchZone || !userFoils || !winningCombinations || !playFields){
			throw &quot;Invalid object has been passed to update the WinPopup!&quot;;
		}
		var winPopupWinTableContainer = this.$(&quot;#win-popup-wintable-container&quot;);

		while(winPopupWinTableContainer.firstChild){
			winPopupWinTableContainer.removeChild(winPopupWinTableContainer.firstChild);
		}

		for (key in winningCombinations){

			// here we have to deal with the normal winning combinations only
			// -1 means
			if (isNaN(parseInt(key)) || key &lt;= 0){
				continue;
			}

			var columns = [
				userFoils[parseInt(key) - 1],
				currencyManager.formatAmount(winningCombinations[key].winAmount, false, true, 2) + &quot;,-&quot;
			];

			winPopupWinTableContainer.appendChild(this.createRow(columns));
		}

		// Total row
		var totalWinAmount = currencyManager.formatAmount(totalWin, false, true, 2) + &quot;,-&quot;;
		totalRow = this.createRow([getLocalisedString(&quot;ingame.popup.total.text&quot;), totalWinAmount]);

		winPopupWinTableContainer.appendChild(totalRow);
	}
});
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
